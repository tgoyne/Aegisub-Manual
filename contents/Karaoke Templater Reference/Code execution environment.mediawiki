The Lua code in code blocks and on code lines is run in a separate global environment such that it won't accidentally disturb the main script function.

You can store your own data in this environment for use later, for example pre-compute some values on code-lines and later insert them using code blocks, but it also contains several pre-defined variables and functions designed to make it easier writing effect templates.

It's important to understand that the contents of code execution environment and the [[Karaoke Templater Reference: Inline variables|inline-variables]] ($-variables) are not related. You cannot change an inline-variable by changing something in the code execution environment nor can you add new ones. However, you can create and re-define the contents of the code execution environment.

== Line and syllable information ==

The code execution environment contains a few variables pointing to the current line and syllable structure being processed, as well as some more supporting tables. These are just references to the structures produced by [[Automation 4 karaskel.lua#Data structures|karaskel]] and are not modified in any way.

You should treat these as read-only, except <code>line</code>. If you change the other ones, the kara-templater script might start misbehaving.

* '''line''' - The line currently being produced, changing this will affect the resulting line in the file. See the '''[[Automation 4 karaskel.lua#Dialogue line table|reference for dialogue line tables]]'''.
* '''orgline''' - The original line, this is the source line the current syllable is located on.
* '''syl''' - The current syllable structure. If the current template is a ''furi'' template, it's the current furigana syllable. If the current template has one or both of the ''char'' or ''multi'' modifiers, this is a pseudo-syllable structure, a copy of the original syllable structure with several values changed to look like the current part of the syllable being processed. Also see the '''[[Automation 4 karaskel.lua#Karaoke and furigana syllable tables|reference for syllable tables]]'''.
* '''basesyl''' - Usually the same as <code>syl</code>, except when the template has the ''char'' or ''multi'' modifier, then this is the original syllable. (If <code>syl == basesyl</code> is true, then the current template is neither ''char'' nor ''multi''.)
* '''meta''' - Contains various metadata about the script, namely the contents of the ''Script Info'' section. Most importantly, it has the <code>res_x</code> and <code>res_y</code> fields describing the script resolution.

All of these variables are reset to <code>nil</code> whenever processing starts for a new line, except <code>meta</code>. They are then set to the relevant value whenever processing hits a new stage. This means that, for example ''pre-line'' templates only has <code>line</code> and <code>orgline</code> set and both <code>syl</code> and <code>basesyl</code> are <code>nil</code>. In ''code once'' templates, all of the variables except <code>meta</code> are <code>nil</code>.

== Standard libraries and related things ==

Both the [http://www.lua.org/manual/5.1/manual.html#5.4 '''string'''] and [http://www.lua.org/manual/5.1/manual.html#5.6 '''math'''] Lua standard libraries are imported into the execution environment, as they are generally useful.

You can also access the main execution environment of the kara-templater script itself using the <code>'''_G'''</code> (underscore capital-G) variable and through that access the rest of the Lua standard library. For example, <code>_G.table.sort</code> refers to the regular <code>table.sort</code> function. See the [http://www.lua.org/manual/5.1/manual.html#5 Lua 5.1 manual] for details on the available libraries.

You can also access the Automation 4 Lua standard libraries through the <code>_G</code> variable: [[Automation 4 karaskel.lua|karaskel.lua]], [[Automation 4 unicode.lua|unicode.lua]] and [[Automation 4 utils.lua|utils.lua]].

There is also the self-reference <code>'''tenv'''</code> variable, this refers to the code execution environment itself. This means that <code>tenv.tenv == tenv</code> is true.

== Utility functions ==

These functions help do more complex modifications of the output line (the <code>line</code> variable) and are unavoidable when creating complex effects.

Currently there is just one, but it is possible to define your own functions in code lines.

=== retime ===

Synopsis: <code>retime(mode, startadjust, endadjust)</code>

This function is usually used once in a template in a code block by itself. It adjusts the start and end time of the output line in various ways.

The ''mode'' parameter determines how the start and end times of the line are changed, it must be a string with one of the following values. Because it must be a string, the name of the mode must be enclosed in quotation marks!

The ''startadjust'' and ''endadjust'' parameters slightly change meaning based on the mode, but generally is a number of milliseconds added to the "base" time controlled by the mode.

Possible ''mode''s:

* '''abs''' or '''set''' - Both ''startadjust'' and ''endadjust'' are used as absolute time values to set the start and end time of the line directly.
* '''preline''' - Intended to make effects that happen before the actual line start. Both start and end time of the line are set to the start time of the line, then ''startadjust'' is added to the start time and ''endadjust'' added to the end time. Usually ''startadjust'' should be negative here and ''endadjust'' be zero.
* '''line''' - Use the regular line timings and just add ''startadjust'' to the start time and ''endadjust'' to the end time.
* '''start2syl''' - Intended to make the look of the syllable from the start of the line until it is highlighted. The start time of the line is kept and the end time is set to the start time of the syllable. Use ''startadjust'' and ''endadjust'' to offset the times.
* '''presyl''' - Similar to ''preline'' but for the syllable timing instead.
* '''syl''' - From start of syllable to end of syllable.
* '''postsyl''' - Similar to ''presyl'' but the base timing is the syllable end time instead of start time. You will usually want to use a zero ''addstart'' and positive ''addend'' here.
* '''syl2end''' - The time from the end of the syllable to the end of line, similar to ''start2syl''.
* '''postline''' - Similar to ''postsyl'' but for the line timing instead.

There is also a special ''mode'':

* '''sylpct''' - Both of ''startadjust'' and ''endadjust'' are treated as percentage values from 0 to 100 and are used to set the line timing to cover that part of the syllable's time.

Be careful with the <code>retime</code> function on ''line'' templates, if you use it directly on a ''line'' template it will probably not do what you want. You should only use it on ''pre-line'', ''syl'' and ''furi'' templates. You should also only use it once in each template.

The <code>retime</code> function always returns the empty string (<code>""</code>) which will cause it to output nothing when used in code blocks, but still evaluate to true if used in boolean expressions.

{{Examplebox|
 template syl: !retime("preline", -1000, 0)!{\pos($scenter,$smiddle)\an5\fscx0\fscy0\t(\fscx100\fscy100)}

This creates a kind of "pop-in" effect for the syllables that lasts 1 second (1000 milliseconds) before the actual line timing. The two important things to code: Quotation marks around <code>"preline"</code> and that the start offset is negative, -1000, because the start time needs to be moved backwards.
}}
{{Examplebox|
 template syl: !retime("syl", 0, 0)!{\pos($x,$y)\t(\fscx360)}

Makes the syllable spin around itself during its highlight. Unless you also have ''syl'' templates retimed to <tt>start2syl</tt> and <tt>syl2end</tt> the syllable will only be visible during its highlight. Note how retiming a syllable line to just the syllable time makes it unneeded to put start and end times in the <code>\t</code> tag, they default to the duration of the entire line and here the duration of the line is the duration of the syllable.
}}
{{Examplebox|
 template syl: !retime("sylpct", 0, 50)!{\move($x,$y,$x,!$y-10!)}
 template syl: !retime("sylpct", 50, 100)!{\move($x,!$y-10!,$x,$y)}

These two templates together makes the syllable move 10 pixels upwards during the first half of its highlight and back down during the last half. Using <code>retime</code> is an easy way to get multiple <code>\move</code> tags to affect the same syllable; there can only be one <code>\move</code> tag on one line, but if you split the line into many "chained" times you can create an effect of the same syllable moving in several directions.
}}

== Template execution data ==

These variables either give some further information on the status of the executing template or modify the rules for template execution in some way. They generally work together with specific template modifiers.

=== Looping templates ===

When a template with the ''loop'' or ''repeat'' modifier is running, two new variables are introduced in the code execution environment, <code>'''j'''</code> and <code>'''maxj'''</code>.

* '''maxj''' is the number of loops, ie. simply the parameter given to the ''loop'' modifier.
* '''j''' is the loop iteration counter, it starts at 1 in the first iteration and ''maxj'' in the last.

{{Examplebox|
 template syl loop 5: {\an5\pos($x,$y)\1a&HFF&\bord2\shad0\t($start,$end\fscx!100+<u>j</u>*3!\fscy!100+<u>j</u>*3!\3a&HFF&)}

The syllable fill and shadow is hidden so only the border is visible, then several copies of the that border-only line is made through the loop, and made to "explode" to different, growing sizes using the <code>j</code> variable.
}}
{{Examplebox|
 template syl loop 20: {\move($x,$y,!$x+15*math.cos(math.pi*2*<u>j</u>/<u>maxj</u>)!,!$y+15*math.sin(math.pi*2*<u>j</u>/<u>maxj</u>)!,$start,$end)\t($start,$end,\alpha&HFF&)}

Here looping is used to [http://en.wikipedia.org/wiki/Unit_circle#Trigonometric_functions_on_the_unit_circle calculate several points on a circle] with radius 15 and make the syllables move out to those. Just by changing the number of loops in the Effect field you can make a more detailed circle because <code>j/maxj</code> is used to calculate how large a portion of the total number of loops have been completed.
}}

=== Conditional templates with fxgroup ===

The ''fxgroup'' modifier uses a special table <code>'''fxgroup'''</code> in the code execution environment to control whether a template will be executed or not.

The parameter given to the ''fxgroup'' modifier names a key (always a string) in the <code>fxgroup</code> table in the execution environment, and when a template assigned to an fxgroup is about to be executed, the value for that key in the <code>fxgroup</code> table is looked up. If the value is true or the key doesn't exist, the template is executed, if it's false the template is skipped.

While you can technically use any text string for fxgroup names, because they're used in Lua code it's best to avoid ones that overlap with Lua reserved words such as <code>end</code>, <code>break</code>, <code>return</code> and several more.

{{Examplebox|
 code syl: <u>fxgroup.long &#x3D; (syl.duration > 200)</u>
 template syl noblank: all here: 
 template syl <u>fxgroup long</u>: is long: 
 karaoke: {\k10}huh? {\k40}wee~~

It's important to understand the template execution order to understand this example. For each input syllable (ie. "huh?" and "wee~~") all the templates and code lines are run in the order they appear.

This means that for "huh?", first the code line is run. It determines that the duration of that syllable is less than 200 ms and thus sets ''fxgroup.long'' to false. The first template has no fxgroup, so it's applied to the syllable then, outputting a line "all here: huh?", but the second template has fxgroup "long". This fxgroup was disabled for that syllable by the code line, so that template is not run at all.

For "wee~~", the code line determines that its duration is longer than 200 ms, so the "long" fxgroup is enabled. Then the first template outputs its line, "all here: wee~~", and when the second template is to run, its fxgroup is enabled now so it's also run, outputting "is long: wee~~".

Neither of the two templates will output anything for the zero'th syllable. The first template, because it has the "noblank" modifier, and the second because the zero'th syllable's duration is too short for the fxgroup to be enabled.
}}